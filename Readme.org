* git-complete.el

Yet another completion engine powered by =git grep=

=git grep= を使った補完エンジン

** Description

=git-complete= provides an interactive command which, when invoked,
scans the current git project with =git grep= and suggests what you
may want to insert.

[[screencast.gif]]

=git-complete= CAN:

- complete *not just a symbol but the whole idiom* if appropreate,
  unlike other completion engines (rather like snippet engines)

- be used as an "omni (smart) completion" engine, i.e. =git-complete=
  tries to suggest expressions you may want to insert next, according
  to the context, *even when you don't remember it*, by grepping your
  project (class methods after a class name, typical argument for a
  function, for examples)

- be used with *no per-language configurations or dictionaries*,
  unlike snippet engines or omni-completion engines

=git-complete= CAN'T:

- complete expressions which has not been used in the git project yet

- start completion automatically, since it's a bit laggy to git grep
  over the git repo (especially for the first invokation in the
  project)

- be 100% accurate, since =git-complete= has no knowledge about the
  language you are coding in

EXTRA FEATURES:

- "autopair"
  - =git-complete= (optionally) tries to keep the parenthesis balance
    by inserting or deleting some parens if appropreate

- DWIM newline insertion
  - =git-complete= tries to insert newline after completion if you may
    want so

*** See also:

The =git grep= idea is taken from =auto-programming.el= by hitode909.

https://github.com/hitode909/emacs-auto-programming

- Atom version: =atom-auto-programming= by the author of
  =auto-programming.el=
  - https://github.com/hitode909/atom-auto-programming

- Vim version: =vim-auto-programming= by haya14busa
  - https://github.com/haya14busa/vim-auto-programming

** Quickstart
*** Installation

#+begin_src emacs-lisp
  (require 'git-complete)
#+end_src

and (optionally) bind some keys.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-c") 'git-complete)
#+end_src

*** Examples

(Consider "|" as the cursor in following examples)

Open a file under a git repo, and =M-x git-complete=,

- after a part of a package name:

  #+begin_src perl
    SHA|
  #+end_src

  completes the import statement.

  #+begin_src perl
    use Digest::SHA;
    |
  #+end_src

- after a constructor:

  #+begin_src javascript
    var foo = moment().|
  #+end_src

  suggests method names frequently used in your project.

  #+begin_src javascript
    var foo = moment().format(|
  #+end_src

  and =M-x git-complete= (again) suggests typical arguments to the
  method frequently used in your project.

  #+begin_src javascript
    var foo = moment().format("YYYY-MM-DD HH:mm:ss"|
  #+end_src

- after a newline:

  #+begin_src perl
    use strict;
    |
  #+end_src

  suggests the next line which usually follows "use strict;" in your
  project.

  #+begin_src perl
    use strict;
    use warnings;
    |
  #+end_src

** Customizations

- =git-complete-enable-autopair= : either git-complete should keep the
  parenthesis balance during completion

- =git-complete-ignore-case= : either to use =--ignore-case= option or
  not when git grepping

See "How it works" section for details:

- =git-complete-threshold=
- =git-complete-whole-line-completion-threshold=
- =git-complete-next-line-completion-threshold=
- =git-complete-repeat-completion=

** How it works

There are two completion methods:

- current-line completion
- next-line completion

and a fallback method:

- omni-completion

in git-complete, which work as follows:

- current line has no characters before the cursor ?
  - yes -> try "next-line completion"
  - no -> try "current-line completion"
    - current-line completion failed ?
      - -> try "omni completion"

Each completion methods works as follows:

*** Current-line completion

example condition:

: React|            * consider | as the cursor

1. Collect lines containing "React" in your git repo, by =git grep=
   -ing with "React"

   : $ git grep -F -h "React"
   : import React from 'react';
   : export default class extends React.Component {
   : export default class extends React.Component {
   : import React from 'react';
   : export default class extends React.Component {
   : import React from 'react';
   : import ReactDOM from 'react-dom';
   : export default class extends React.Component {
   :     ReactDOM.render(<MyComponent />);
   : import React from 'react';
   : export default class extends React.Component {
   : import ReactDOM from 'react-dom';
   :     ReactDOM.render(<AnotherComponent />);
   : ...

2. Strip some characters off from the end of each lines, until it gets
   "common enough" (defined by =git-complete-threshold=). If no
   characters are dropped from a line, it is called an "exact match"

   : |                                               | frequency | exact ? |
   : +-----------------------------------------------+-----------+---------|
   : | export default class extends React.Component{ |       60% |     yes |
   : | import React from 'react';                    |       30% |     yes |
   : | import ReactDOM from 'react-dom';             |        5% |     yes |
   : | ReactDOM.render(                              |        5% |      no |
   : | ...                                           |       ... |     ... |

   (argument to =ReactDOM.render= is dropped, since they does not
   appear "commonly")

   - If no such common substrings are found here, fall back to
     omni-completion

3. For each suggestions,

   - If it is an "exact match" and satisfies
     =git-complete-whole-line-completion-threshold= (in addition to
     =git-complete-threshold=), then mark it as a "whole-line"
     completion candidate

   - Otherwise, trim characters before the query ("React" in this
     example) and the query itself

   : |                                                | frequency | exact ? | whole-line ? |
   : +------------------------------------------------+-----------+---------+--------------|
   : | export default class extends React.Component { |       60% |     yes |          yes |
   : | import React from 'react';                     |       30% |     yes |          yes |
   : | DOM from 'react-dom';                          |        5% |     yes |           no |
   : | DOM.render(                                    |        5% |      no |           no |
   : | ...                                            |       ... |     ... |          ... |

4. Query user to select a suggestion

5. If the selected suggestion

   - is a "whole-line" completion, then delete all characters in the
     line, then insert the completion and a newline

     before:

     : React|

     after:

     : import React from 'react';
     : |

   - is not a "whole-line" completion, just insert the completion

     before:

     : React|

     after:

     : ReactDOM.render(|

**** Omni completion

example condition:

: var foo = bar(MyClass.|

If current-line completion fails (since "var foo = bar(MyClass." does
not appear commonly in the repo), omni-completion works as follows:

1. Let the initial query be "var foo = var(MyClass."

2. =git grep= with the query

3. Trim the lines found, as like a non-"whole-line" completion in
   "current-line completion"

   - If no common substrigs are fonud, drop the first word from the
     query (i.e. new query will be "foo = bar(MyClass.", then
     "bar(MyClass.", finally "MyClass.". This behavior can be
     configured with =git-complete-omni-completion-type=), and back to
     the step 2. If all characters are dropped, fail

5. Query user to select a suggestion, and insert it as like a
   non-"whole-line" completion

*** Next-line completion

example condition:

: use strict;
: |

1. Collect lines next to "use strict;" in your git repo, by git
   grepping with "use strict;"

   : > git grep -F -h -A1 "use strict;"
   : use strict;
   : sub foo {
   : --
   : use strict;
   : use warnings;
   : --
   : use strict;
   : use warnings;
   : --
   : use strict;
   : sub bar {
   : --
   : use strict;
   : use utf8;
   : --
   : ...

2. Find "whole-line" matches (see "Current-line completion" section
   for what "whole-line" means) according to
   =git-complete-next-line-completion-threshold=

   : |                       | frequency |
   : +-----------------------+-----------|
   : | use warnings;         |       80% |
   : | use utf8;             |       20% |
   : | ...                   |       ... |

   - If no "whole-line" matches are found, fail

3. Query user to select a suggestion, and insert it

** "autopair" feature

When =git-grep-enable-autopair= is non-nil, the parenthesis balance is
always kept during completion.

*** Whole-line (Next-line) completion

- Open paren

  If the completion being inserted has more *open* parens than close
  parens:

  : query:
  : validate|            * consider | as the cursor

  : completion:
  : my %params = Params::Validate::validate(@_, {

  then close parens (and an empty line) are inserted automatically.

  : result:
  : my %params = Params::Validate::validate(@_, {
  :     |
  : })

- Close paren

  If the completion being inserted has more *close* parens than open
  parens:

  : query:
  : my_awesome_function(
  :   |
  : )

  : completion:
  : an_awesome_argument)

  then the close parens in the next line is mereged into the
  replacement :

  : result:
  : my_awesome_function(
  :   an_awesome_argument)
  : |

  If no such close paren exist in the next line, then open parens are
  inserted at the beginning of the replacement, instead.

  : query:
  : my_awesome_function(
  :   |
  :   another_awesome_argument
  : );

  : result:
  : my_awesome_function(
  :   (an_awesome_argument)
  :   |
  :   foo
  : );

  (I'm not sure this behavior is very useful ... but just to keep the
  balance. maybe improved in the future versions ... ?)

*** Otherwise

- Open paren

  If the completion being inserted has more *open* parens than close
  parens:

  : query:
  : var formatted = moment.format|

  : completion:
  : ("YYYY-MM-DD HH:mm:ss",

  then close parens are inserted automatically (without an empty line,
  unlike whole-line completion).

  : result:
  : var formatted = moment.format("YYYY-MM-DD HH:mm:ss",|)

- Close paren

  If the completion being inserted has more *close* parens than open
  parens:

  : query:
  : var foo = my_awesome_function(|)

  : completion:
  : an_awesome_argument), bra, bra, bra

  then the close paren and characters outside the paren (=bra, bra,
  bra=) are dropped from the completion:

  : result:
  : var foo = my_awesome_function(an_awesome_argument|)
